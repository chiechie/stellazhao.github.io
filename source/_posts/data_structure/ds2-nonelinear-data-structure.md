---
title: 数据结构2 非线性数据结构
author: chiechie
mathjax: true
date: 2021-07-11 13:20:51
tags:
- 编程
- 数据结构
- 图数据
categories: 
- 编程
---

## 总结

1. 非线形数据结构包括堆，Union Find或者disjoint set。

## 堆和优先队列

1. 优先队列（priority queue）是什么？优先队列是一个抽象数据类型（ADT），跟一般的normal很类似，除了一点，优先队列中的每个元素都有固定的优先级，优先级越高的元素，越先出队（dequeue）。

2. 注意，优先队列只能存储可比较的数据。

3. 优先队列出队（poll）是如何找到最优先的成员的？借助堆（heap）。

4. 优先队列通常是使堆实现，因为对优先队列进行操作时，使用堆构造的优先队列时间复杂度最低。除了堆还有别的数据结构也可以实现优先队列，例如一个无序的链表，但是时间复杂度较高。

5. 堆（heap）是什么？ 堆是一个基于树的数据结构，它满足堆不变性质（也叫堆属性）：堆中的所有的父节点的优先级都大于或者孩子节点的value。最大堆（max heap）是指，父节点的value都大于等于孩子节点。最小堆（min heap）是指，小于或者等于。
  
   ![](./image-20210711093249240.png)
   
6. 什么时候需要使用优先队列？在图算法中会经常用到

   1. 最短路径搜索算法--Dijkstra;s
   2. 动态获取下一个最好的或者最差的元素
   3. huffman编码（无损数据压缩）
   4. 图遍厉中的Best优先搜索算法，例如A*，使用优先队列持续获取下一个最有潜力的节点
   5. 最小生成树（Mininum Spannning Tree， MST）算法中会用到。

7. 将最小优先队列转换为最大优先队列：很多编程语言的标准库只提供最小优先队列的抽象数据类型，即按照值越小，优先级越高，但是实际应用中我们也会需要用到最大优先队列。如何使用已有的最小优先队列来满足我们构造最大优先队列的需求呢？将元素的值取相反数，然后使用最小优先队列排序。

8. 堆又很多种，binary heap/binomial heap等，最常用的堆是**二叉堆**（binary heap）。二叉堆是一个二叉树，并且支持堆不变性，二叉树中，每个节点都有2个孩子。

9. 完全二叉树：除了最后一层，每一层都是完全填充的，并且节点都会尽量往左边排。完全二叉树在数据插入的时候很有用

   ![](./image-20210711100432168.png)

10. 怎么表示二叉堆？--数组。

   ![](./image-20210711102017358.png)

11. 找到某个节点的父亲节点和孩子节点，利用左下方的公式计算相应的父节点/子节点的索引，然后去数组查找该索引对应的取值。
    ![](./image-20210711102047154.png)

12. 在二叉堆中添加元素：先将该元素添加到最后一层的，最后一个节点的右边，然后不断的使用冒泡的方法，跟父亲节点互换位置,

13. 从二叉堆中删除顶端元素，时间复杂度为O（logn），从二叉堆中删除某个值的元素，时间复杂度为O(n),  因为时间花在找到这个元素上面了。

14. 有没有办法可以提升查找二叉堆中某个元素速度的方法呢？hash table，即提前将value和索引pair存到一个table中，要搜索的时候去查这个table就好了。这个表叫哈希表（hashtable）， key是hash（value），value是索引。如果有多个相同的值，就存成一个index set

    ![](./image-20210711104111050.png)

##  Union-Find 

1. Union-Find 也叫非连通集合（disjoint set），也是一种数据结构，主要操作是find 合uninion

   1. find：给定一个element，union find 返回该element所属的group

   2. uninon：merge 2 groups，将其中一个group的root变为另外一个group的root的子节点

      ![](./image-20210711110158015.png)

2. union find在哪里会被用到？最小生成树算法--kruskal：

   ![](./image-20210711110757010.png)

3. Union find这个数据结构可以使用hashtable + 数组实现

   ![](./image-20210711115717168.png)

4. union find 应用之--path压缩, 每次union的时候，将属于某个pattern的所有节点全部指向root

   

## 二叉树 和 二叉查找树



1. 树是什么？一个无向图，无环的连通图，有N个节点，N-1条边
2. 树中任意一个节点都能成为一个root节点。
3. 子树（subtrees）可能是一个叶子结点
4. 二叉树：是一种特殊的树，树中每个节点最多只有2个子节点。
5. 二叉查找树（binary seach tree）是一种特殊的二叉树，树中的所有子树都满足二叉查找树不变性（BST invariant），即左边的树更小，右边的树更大。

6. 二叉查找树有什么用？
   1. 可以实现很多抽象的数据类型。例如map，set
   2. 可以用来实现平衡二叉查找树（balanced binar用search trees）
   3. 实现语法树：编译器和计算机会用到
   4. Treap--一个基于概率的数据结构，使用了一个随机的二叉搜索树。
7. 如何在二叉查找树中插入一个元素？二叉查找树要求元素可比较大小，先查找插入位置，然后插入，注意这是一个贪婪的对此迭代的过程，总共有4种位置以及对应的行动
   1. if 插入值< case: recurse down 左子树
   2. if 插入值> case:recurse down 右子树
   3. if 插入值== case: do something
   4. if 无节点可供插入值比较:的创建一个新的节点

8. 平均来看，在二叉查找树种插入一个元素需要对数时间，在最坏情况下（如下图， 需要平衡二叉搜索树），插入一个元素退化为线性时间，

   ![image-20210712095559490](./image-20210712095559490.png)

9. 在二叉查找树中删除一个元素的步骤：

   1. 找到元素在树种的位置： 

      1. 使用贪婪算法从根节点点开始持续查找，当我们找到一个null戒电视，迭代结束，意味着这个二叉树中没有这个元素。
      2. 每遍历到一个点，比较当前值和value的大小，当相等时，返回；当value小于该节点时，去左子树继续找；当value=该节点时，去右子树继续找。

   2. 找到了二叉查找树种想删除节点，要删除该节点了，也面临4种情况：这个节点在是叶子结点；这个节点只有右子树；这个节点只有左子树；既有左子树又有右子树。

      ![image-20210712100625802](./image-20210712100625802.png)

      - 叶子节点直接删除，节点只有一个子树的，将子树顶上来
      - 最复杂的是被删除的节点有两个子树，可以找左子树的最大的节点/右子树最小的节点，将这个值 复制到root（上图中的⭕️），注意 左子树的最大的节点/右子树最小的节点 是左子树最右边路径的叶子，是右子树最左边路径的叶子，删除该节点的操作必然输入case1/2/3的一种，即这个节点最多包含一个子树。



## Fenwick树【todo】

## 平衡二叉查找树【todo】

1. 一个平衡二叉查找树是一个自平衡二叉叉招数，这个树会调整自己的顺序，以保持一个低的层数，允许更快速的操作，例如插入和删除。
2. 相对二叉查找树，一般情况下，增删改查的平均时间复杂度是对数级别，最坏情况下，二叉查找树时间复杂度是线性的，平衡二叉查找树的时间复杂度还是非线形的。
3. 平衡二叉树的秘密配方：树不变性；树的翻转（rotation）。

【如何操作？】



## 树遍历算法

1. 树遍历的三个算法：先序遍历(preorder traversal)，中序遍历（inorder traversal）后序遍历（postorder traversal）。递归调用，开始遍历到一个节点，将这个节点入栈，该节点遍历完，出栈。

2. 先序遍历(preorder traversal)：先打印当前节点的值，再开始遍历左右节点。top down

   ![image-20210712105721400](./image-20210712105721400.png)

3. 中序遍历（inorder traversal）：把左子树遍历完，打印当前值，开始遍历右子树。bottom up， 块状优先

   ![image-20210712105759814](./image-20210712105759814.png)

4. 后序遍历（postorder traversal）：遍历完子节点后，打印当前节点的值，bottem up的方式。

   ![image-20210712105840283](./image-20210712105840283.png)

5. level order 遍历，需要广度优先搜索(Breadth First Search) 以top down的方式遍历

6. 怎么实现广度优先搜索(Breadth First Search)?

   1. 构造一个队列，放置当前待访问的节点。初始值是root，
   2. 每访问一个节点，让这个节点出列（dequeue），将该节点的所有子节点入列（enqueue）。
   3. 直到访问到最后一层，只dequeue没有enque，queue变为空时，就访问完成




## 哈希表

1. hash函数是什么？就是一个函数，它把key映射为固定范围内的一个数。key可以是string，list等多种类型

2. hash函数的属性，value不同对应的key一定不相同，key相同对应的value一定相同。

3. key是什么都可以，只要是唯一值就可以了，value可以存任何值，例如存储一篇文章中，所有单词出现的次数。

4. hash函数需要解决哈希冲撞（hash collision）的问题，有两个方法

   1. separate chaining： 维护一个单独的数据结构例如链表（数组，二叉树，自平衡二叉树都行），把一个value对应的多个key存到一起。separate chaining是最常用的方法。

   2. 公开地址（open addressing）：需要关注哈希表的负载，需要hash value已经占用的话，就找一个未被占用的slot（怎么找？需要构造一个概率函数），把key存进去

      > 概率函数probing function）有时候会陷入死循环，更合适的做法是找一个值域超过N的函数 作为概率函数。

5. 哈希表是一个数据结构，提供key到value的映射，映射规则是hashing

   

## 后缀数组

1. 后缀（suffix）一个字符串的尾端的子字符串。

2. 后缀数组（suffix array）是一个数组，由一个字符串的所有后缀组成，成员个数为字符串长度。

3. 后缀数组比后缀树在空间上更优，功能上比后缀树还多一点信息--LCP数组。

4. 最长公共前缀(LongestCommonPrefix, LCP)是一个数组，每个值记录两个相邻（按照首字母排序）后缀子串的有多少个相同的字符。

   ![image-20210713113655458](./image-20210713113655458.png)

5. 有很多方法可以构造LCP向量

6. 怎么计算一个字符串包含的所有的字符子串，要去重：

   ![image-20210713122803380](./image-20210713122803380.png)

7. 后缀数组的应用之--查找最长的公共字符子串

   

   

   ## 带索引的优先队列[todo]

   Indexed Priority Queue 

   



## 参考

1. [Data Structures Easy to Advanced Course - Full Tutorial from a Google Engineer](https://www.youtube.com/watch?v=RBSGKlAvoiM&t=11600s)
2. [Algorithms & data structures project](https://github.com/akzare/Algorithms)

